{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { AsyncState } from \"../components/async\";\nimport { useRef, useState } from \"react\";\nimport { parseError } from \"../util/error\";\nconst DefaultOptions = {\n  AvailableMsg: \"\",\n  AvailableAfterError: true,\n  ThrowError: false\n};\nexport default function useAsync(defaultState = AsyncState.Available, duration = 300) {\n  // Stores whether it is currently already running or not. If it is running that means we are adding to\n  // the end of the queue, which also means that we should be running any side effects as it will run itself.\n  const isRunning = useRef(false); // This is the handle for the interval while it is running. It will be cleared when there are no more\n  // items left in the queue.\n\n  const it = useRef(null); // Queue will store future statuses that should be shown.\n\n  const queue = useRef([]); // Current status and message to show (if any)\n\n  const {\n    0: status,\n    1: setStatus\n  } = useState(defaultState);\n  const {\n    0: errMsg,\n    1: setErrMsg\n  } = useState(\"\"); // Next is the iterative process. It will continue until the queue is cleared, where upon it needs to set the\n  // statuses `isRunning` and `it` properly to reset the state.\n\n  function next() {\n    if (queue.current.length == 0) {\n      isRunning.current = false;\n      clearInterval(it.current);\n      it.current = null;\n      return;\n    }\n\n    const curr = queue.current.shift();\n    setStatus(curr.Status);\n    setErrMsg(curr.Message);\n  }\n\n  function _setStatus(status, err = \"\") {\n    queue.current.push({\n      Status: status,\n      Message: err\n    });\n\n    if (isRunning.current) {\n      return;\n    }\n\n    isRunning.current = true;\n    it.current = setInterval(next, duration);\n  }\n\n  return {\n    status,\n    setStatus: _setStatus,\n    errMsg,\n    runAsync: async (fn, options = _objectSpread({}, DefaultOptions)) => {\n      _setStatus(AsyncState.Loading);\n\n      try {\n        await fn();\n\n        _setStatus(AsyncState.Success);\n\n        _setStatus(AsyncState.Available, options.AvailableMsg);\n      } catch (err) {\n        console.log(_objectSpread({}, err));\n\n        _setStatus(AsyncState.Error, parseError(err));\n\n        if (options.AvailableAfterError) _setStatus(AsyncState.Available, options.AvailableMsg);\n        if (options.ThrowError) throw err;\n      }\n    }\n  };\n}","map":{"version":3,"sources":["/Users/bryancua/Sites/charityhonor/hooks/use-async.ts"],"names":["AsyncState","useRef","useState","parseError","DefaultOptions","AvailableMsg","AvailableAfterError","ThrowError","useAsync","defaultState","Available","duration","isRunning","it","queue","status","setStatus","errMsg","setErrMsg","next","current","length","clearInterval","curr","shift","Status","Message","_setStatus","err","push","setInterval","runAsync","fn","options","Loading","Success","console","log","Error"],"mappings":";;;;;;AAAA,SAAQA,UAAR,QAAyB,qBAAzB;AACA,SAAQC,MAAR,EAAgBC,QAAhB,QAA+B,OAA/B;AACA,SAAQC,UAAR,QAAyB,eAAzB;AAaA,MAAMC,cAAc,GAAG;AACrBC,EAAAA,YAAY,EAAE,EADO;AAErBC,EAAAA,mBAAmB,EAAE,IAFA;AAGrBC,EAAAA,UAAU,EAAE;AAHS,CAAvB;AAaA,eAAe,SAASC,QAAT,CACbC,YAAY,GAAGT,UAAU,CAACU,SADb,EAEbC,QAAQ,GAAG,GAFE,EAGN;AAEP;AACA;AACA,QAAMC,SAAS,GAAGX,MAAM,CAAC,KAAD,CAAxB,CAJO,CAMP;AACA;;AACA,QAAMY,EAAE,GAAGZ,MAAM,CAAC,IAAD,CAAjB,CARO,CAUP;;AACA,QAAMa,KAAK,GAAGb,MAAM,CAAe,EAAf,CAApB,CAXO,CAaP;;AACA,QAAM;AAAA,OAACc,MAAD;AAAA,OAASC;AAAT,MAAsBd,QAAQ,CAACO,YAAD,CAApC;AACA,QAAM;AAAA,OAACQ,MAAD;AAAA,OAASC;AAAT,MAAsBhB,QAAQ,CAAC,EAAD,CAApC,CAfO,CAiBP;AACA;;AACA,WAASiB,IAAT,GAAgB;AACd,QAAIL,KAAK,CAACM,OAAN,CAAcC,MAAd,IAAwB,CAA5B,EAA+B;AAC7BT,MAAAA,SAAS,CAACQ,OAAV,GAAoB,KAApB;AACAE,MAAAA,aAAa,CAACT,EAAE,CAACO,OAAJ,CAAb;AACAP,MAAAA,EAAE,CAACO,OAAH,GAAa,IAAb;AACA;AACD;;AACD,UAAMG,IAAI,GAAGT,KAAK,CAACM,OAAN,CAAcI,KAAd,EAAb;AACAR,IAAAA,SAAS,CAACO,IAAI,CAACE,MAAN,CAAT;AACAP,IAAAA,SAAS,CAACK,IAAI,CAACG,OAAN,CAAT;AACD;;AAED,WAASC,UAAT,CAAoBZ,MAApB,EAAwCa,GAAW,GAAG,EAAtD,EAA0D;AACxDd,IAAAA,KAAK,CAACM,OAAN,CAAcS,IAAd,CAAmB;AACjBJ,MAAAA,MAAM,EAAEV,MADS;AAEjBW,MAAAA,OAAO,EAAEE;AAFQ,KAAnB;;AAIA,QAAIhB,SAAS,CAACQ,OAAd,EAAuB;AACrB;AACD;;AAEDR,IAAAA,SAAS,CAACQ,OAAV,GAAoB,IAApB;AACAP,IAAAA,EAAE,CAACO,OAAH,GAAaU,WAAW,CAACX,IAAD,EAAOR,QAAP,CAAxB;AACD;;AAED,SAAO;AACLI,IAAAA,MADK;AAELC,IAAAA,SAAS,EAAEW,UAFN;AAGLV,IAAAA,MAHK;AAILc,IAAAA,QAAQ,EAAE,OAAOC,EAAP,EAAgCC,OAAwB,qBAAO7B,cAAP,CAAxD,KAAmF;AAC3FuB,MAAAA,UAAU,CAAC3B,UAAU,CAACkC,OAAZ,CAAV;;AACA,UAAI;AACF,cAAMF,EAAE,EAAR;;AACAL,QAAAA,UAAU,CAAC3B,UAAU,CAACmC,OAAZ,CAAV;;AACAR,QAAAA,UAAU,CAAC3B,UAAU,CAACU,SAAZ,EAAuBuB,OAAO,CAAC5B,YAA/B,CAAV;AACD,OAJD,CAIE,OAAOuB,GAAP,EAAY;AACZQ,QAAAA,OAAO,CAACC,GAAR,mBAAgBT,GAAhB;;AACAD,QAAAA,UAAU,CAAC3B,UAAU,CAACsC,KAAZ,EAAmBnC,UAAU,CAACyB,GAAD,CAA7B,CAAV;;AACA,YAAIK,OAAO,CAAC3B,mBAAZ,EAAiCqB,UAAU,CAAC3B,UAAU,CAACU,SAAZ,EAAuBuB,OAAO,CAAC5B,YAA/B,CAAV;AACjC,YAAI4B,OAAO,CAAC1B,UAAZ,EAAwB,MAAMqB,GAAN;AACzB;AACF;AAhBI,GAAP;AAkBD","sourcesContent":["import {AsyncState} from \"../components/async\"\nimport {useRef, useState} from \"react\"\nimport {parseError} from \"../util/error\"\n\nexport type StatusItem = {\n  Status: AsyncState,\n  Message: string,\n}\n\nexport type RunAsyncOptions = {\n  AvailableMsg: string\n  AvailableAfterError: boolean\n  ThrowError: boolean\n}\n\nconst DefaultOptions = {\n  AvailableMsg: \"\",\n  AvailableAfterError: true,\n  ThrowError: false\n}\n\nexport type Async = {\n  status: AsyncState,\n  setStatus: (status: AsyncState, err?: string) => void,\n  errMsg: string,\n  runAsync: (fn: () => Promise<void>, options?: RunAsyncOptions) => Promise<void>\n}\n\nexport default function useAsync(\n  defaultState = AsyncState.Available,\n  duration = 300\n): Async {\n\n  // Stores whether it is currently already running or not. If it is running that means we are adding to\n  // the end of the queue, which also means that we should be running any side effects as it will run itself.\n  const isRunning = useRef(false)\n\n  // This is the handle for the interval while it is running. It will be cleared when there are no more\n  // items left in the queue.\n  const it = useRef(null)\n\n  // Queue will store future statuses that should be shown.\n  const queue = useRef<StatusItem[]>([])\n\n  // Current status and message to show (if any)\n  const [status, setStatus] = useState(defaultState)\n  const [errMsg, setErrMsg] = useState(\"\")\n\n  // Next is the iterative process. It will continue until the queue is cleared, where upon it needs to set the\n  // statuses `isRunning` and `it` properly to reset the state.\n  function next() {\n    if (queue.current.length == 0) {\n      isRunning.current = false\n      clearInterval(it.current)\n      it.current = null\n      return\n    }\n    const curr = queue.current.shift()\n    setStatus(curr.Status)\n    setErrMsg(curr.Message)\n  }\n\n  function _setStatus(status: AsyncState, err: string = \"\") {\n    queue.current.push({\n      Status: status,\n      Message: err,\n    })\n    if (isRunning.current) {\n      return\n    }\n\n    isRunning.current = true\n    it.current = setInterval(next, duration)\n  }\n\n  return {\n    status,\n    setStatus: _setStatus,\n    errMsg,\n    runAsync: async (fn: () => Promise<void>, options: RunAsyncOptions = {...DefaultOptions}) => {\n      _setStatus(AsyncState.Loading)\n      try {\n        await fn()\n        _setStatus(AsyncState.Success)\n        _setStatus(AsyncState.Available, options.AvailableMsg)\n      } catch (err) {\n        console.log({...err})\n        _setStatus(AsyncState.Error, parseError(err))\n        if (options.AvailableAfterError) _setStatus(AsyncState.Available, options.AvailableMsg)\n        if (options.ThrowError) throw err\n      }\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}