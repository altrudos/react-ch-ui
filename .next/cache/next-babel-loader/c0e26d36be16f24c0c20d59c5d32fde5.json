{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { AsyncState } from \"../components/async\";\nimport { useRef, useState } from \"react\";\nimport { parseError } from \"../util/error\";\nvar DefaultOptions = {\n  AvailableMsg: \"\",\n  AvailableAfterError: true,\n  ThrowError: false\n};\nexport default function useAsync() {\n  var defaultState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : AsyncState.Available;\n  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n  // Stores whether it is currently already running or not. If it is running that means we are adding to\n  // the end of the queue, which also means that we should be running any side effects as it will run itself.\n  var isRunning = useRef(false); // This is the handle for the interval while it is running. It will be cleared when there are no more\n  // items left in the queue.\n\n  var it = useRef(null); // Queue will store future statuses that should be shown.\n\n  var queue = useRef([]); // Current status and message to show (if any)\n\n  var _useState = useState(defaultState),\n      status = _useState[0],\n      setStatus = _useState[1];\n\n  var _useState2 = useState(\"\"),\n      errMsg = _useState2[0],\n      setErrMsg = _useState2[1]; // Next is the iterative process. It will continue until the queue is cleared, where upon it needs to set the\n  // statuses `isRunning` and `it` properly to reset the state.\n\n\n  function next() {\n    if (queue.current.length == 0) {\n      isRunning.current = false;\n      clearInterval(it.current);\n      it.current = null;\n      return;\n    }\n\n    var curr = queue.current.shift();\n    setStatus(curr.Status);\n    setErrMsg(curr.Message);\n  }\n\n  function _setStatus(status) {\n    var err = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    queue.current.push({\n      Status: status,\n      Message: err\n    });\n\n    if (isRunning.current) {\n      return;\n    }\n\n    isRunning.current = true;\n    it.current = setInterval(next, duration);\n  }\n\n  return {\n    status: status,\n    setStatus: _setStatus,\n    errMsg: errMsg,\n    runAsync: function runAsync(fn) {\n      var options,\n          _args = arguments;\n      return _regeneratorRuntime.async(function runAsync$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : _objectSpread({}, DefaultOptions);\n\n              _setStatus(AsyncState.Loading);\n\n              _context.prev = 2;\n              _context.next = 5;\n              return _regeneratorRuntime.awrap(fn());\n\n            case 5:\n              _setStatus(AsyncState.Success);\n\n              _setStatus(AsyncState.Available, options.AvailableMsg);\n\n              _context.next = 16;\n              break;\n\n            case 9:\n              _context.prev = 9;\n              _context.t0 = _context[\"catch\"](2);\n              console.log(_objectSpread({}, _context.t0));\n\n              _setStatus(AsyncState.Error, parseError(_context.t0));\n\n              if (options.AvailableAfterError) _setStatus(AsyncState.Available, options.AvailableMsg);\n\n              if (!options.ThrowError) {\n                _context.next = 16;\n                break;\n              }\n\n              throw _context.t0;\n\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, [[2, 9]], Promise);\n    }\n  };\n}","map":{"version":3,"sources":["/Users/bryancua/Sites/charityhonor/hooks/use-async.ts"],"names":["AsyncState","useRef","useState","parseError","DefaultOptions","AvailableMsg","AvailableAfterError","ThrowError","useAsync","defaultState","Available","duration","isRunning","it","queue","status","setStatus","errMsg","setErrMsg","next","current","length","clearInterval","curr","shift","Status","Message","_setStatus","err","push","setInterval","runAsync","fn","options","Loading","Success","console","log","Error"],"mappings":"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","sourcesContent":["import {AsyncState} from \"../components/async\"\nimport {useRef, useState} from \"react\"\nimport {parseError} from \"../util/error\"\n\nexport type StatusItem = {\n  Status: AsyncState,\n  Message: string,\n}\n\nexport type RunAsyncOptions = {\n  AvailableMsg: string\n  AvailableAfterError: boolean\n  ThrowError: boolean\n}\n\nconst DefaultOptions = {\n  AvailableMsg: \"\",\n  AvailableAfterError: true,\n  ThrowError: false\n}\n\nexport type Async = {\n  status: AsyncState,\n  setStatus: (status: AsyncState, err?: string) => void,\n  errMsg: string,\n  runAsync: (fn: () => Promise<void>, options?: RunAsyncOptions) => Promise<void>\n}\n\nexport default function useAsync(\n  defaultState = AsyncState.Available,\n  duration = 300\n): Async {\n\n  // Stores whether it is currently already running or not. If it is running that means we are adding to\n  // the end of the queue, which also means that we should be running any side effects as it will run itself.\n  const isRunning = useRef(false)\n\n  // This is the handle for the interval while it is running. It will be cleared when there are no more\n  // items left in the queue.\n  const it = useRef(null)\n\n  // Queue will store future statuses that should be shown.\n  const queue = useRef<StatusItem[]>([])\n\n  // Current status and message to show (if any)\n  const [status, setStatus] = useState(defaultState)\n  const [errMsg, setErrMsg] = useState(\"\")\n\n  // Next is the iterative process. It will continue until the queue is cleared, where upon it needs to set the\n  // statuses `isRunning` and `it` properly to reset the state.\n  function next() {\n    if (queue.current.length == 0) {\n      isRunning.current = false\n      clearInterval(it.current)\n      it.current = null\n      return\n    }\n    const curr = queue.current.shift()\n    setStatus(curr.Status)\n    setErrMsg(curr.Message)\n  }\n\n  function _setStatus(status: AsyncState, err: string = \"\") {\n    queue.current.push({\n      Status: status,\n      Message: err,\n    })\n    if (isRunning.current) {\n      return\n    }\n\n    isRunning.current = true\n    it.current = setInterval(next, duration)\n  }\n\n  return {\n    status,\n    setStatus: _setStatus,\n    errMsg,\n    runAsync: async (fn: () => Promise<void>, options: RunAsyncOptions = {...DefaultOptions}) => {\n      _setStatus(AsyncState.Loading)\n      try {\n        await fn()\n        _setStatus(AsyncState.Success)\n        _setStatus(AsyncState.Available, options.AvailableMsg)\n      } catch (err) {\n        console.log({...err})\n        _setStatus(AsyncState.Error, parseError(err))\n        if (options.AvailableAfterError) _setStatus(AsyncState.Available, options.AvailableMsg)\n        if (options.ThrowError) throw err\n      }\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}